//? TEORIA EXTRA:
// Nota histÂ´orica: Patil introdujo este problema en 1971 problema como una crÂ´Ä±tica a la universalidad
// de los semÂ´aforos. Dijkstra planteaba que sus semÂ´aforos podÂ´Ä±an tomarse como la Â´unica primitiva
// necesaria para escribir programas concurrentes, construyendo todo el resto (mutex, CV, etc) a partir
// los mismos. Para este problema de los fumadores, Patil demuestra que no puede resolverse usando
// semÂ´aforos, mientras se den dos condiciones:
// 1. No puede modificarse al agente. Esta restricciÂ´on proviene de pensar que el agente puede ser el
// Sistema Operativo, que notifica la disponibilidad de ciertos recursos. No es realista modificar al
// SO para cada problema que aparece en el espacio de usuario.
// 2. Que no puedan usarse sentencias condicionales. Esta Â´ultima restricciÂ´on no es sensata, y la vamos
// a ignorar, permitiendo resolver el problema. La justificaciÂ´on original era que los semÂ´aforos se
// introdujeron explÂ´Ä±citamente para evitar el testeo repetido de una condiciÂ´on (i.e. busy-waiting).
// Patil concluye que los semÂ´aforos son insuficientes, y propone una nueva operaciÂ´on P(s1, . . . , sn) que
// bloquea haciendo P de n semÂ´aforos a la vez, y los toma de manera atÂ´omica cuando sea posible.
// Algunos aËœnos despuÂ´es, en 1975, David Parnas presenta una soluciÂ´on cumpliendo ambas condiciones,
// exactamente lo que Patil habÂ´Ä±a demostrado imposible. Â¿El truco? Parnas usÂ´o un array de semÂ´aforos,
// algo que la prueba de Patil excluÂ´Ä±a de manera implÂ´Ä±cita. A la vez, Parnas criticaba la restricciÂ´on
// (2), argumentando que no es realista prohibir condicionales, por mÂ´as que sÂ´Ä± sea realista prohibir el
// busy-waiting.
// Extra: Â¿CÂ´omo resolverÂ´Ä±a el problema con el P n-ario? Â¿CÂ´omo resolverÂ´Ä±a el problema usando un array
// de semÂ´aforos?

ğŸ” Â¿Por quÃ© es problemÃ¡tico el cÃ³digo original?
Los fumadores hacen sem_trywait(...) en un bucle.

Si el ingrediente no estÃ¡, lo devuelven y siguen dando vueltas (polling + condicionales).

Esto es busy-waiting disfrazado, porque cada fumador sondea constantemente si los ingredientes estÃ¡n listos.

Aunque el sem_trywait no bloquea, lo estÃ¡n usando con mutex y ciclos while(1), lo cual consume CPU innecesariamente.

ğŸ’¡ Â¿QuÃ© propuso Patil? P(s1, ..., sn)
Una operaciÃ³n atÃ³mica que toma varios semÃ¡foros juntos si todos estÃ¡n disponibles.

Si alguno no estÃ¡ disponible, no toma ninguno y se bloquea hasta que se pueda hacer el P completo.

Eso permitirÃ­a a un fumador bloquearse esperando justo los dos ingredientes que necesita, sin rondas ni busy-waiting.

Ejemplo de lÃ³gica (imaginaria, ya que P mÃºltiple no existe en sistemas reales):
-----------------------
P(papel, tabaco); // bloquea hasta que haya papel Y tabaco disponibles
// ahora sÃ­, fumar
-----------------------
Cada fumador esperarÃ­a exactamente los dos ingredientes que le faltan, sin verificar uno por uno, y el sistema lo desbloquearÃ­a solo cuando estÃ©n los dos.


ğŸ§  Â¿QuÃ© hizo Parnas con un array de semÃ¡foros?
Parnas esquivÃ³ la imposibilidad teÃ³rica de Patil usando 1 semÃ¡foro por combinaciÃ³n posible de ingredientes.

Hay 3 combinaciones de 2 ingredientes entre 3:

papel + tabaco â†’ para el fumador con fÃ³sforos

tabaco + fÃ³sforos â†’ para el fumador con papel

papel + fÃ³sforos â†’ para el fumador con tabaco

Entonces:

El agente al poner dos ingredientes, activa uno solo de esos 3 semÃ¡foros (el que corresponde a la combinaciÃ³n entregada).

Cada fumador espera solo en su semÃ¡foro.

No hay polling, no hay trywaits ni mutexes, ni condicionales.

Ejemplo (simplificado):
----------------------------------------------------
sem_t combinacion[3]; // uno para cada par de ingredientes

// agente:
switch (random() % 3) {
  case 0: // papel + tabaco
    sem_post(&combinacion[0]); break;
  case 1: // fÃ³sforos + tabaco
    sem_post(&combinacion[1]); break;
  case 2: // papel + fÃ³sforos
    sem_post(&combinacion[2]); break;
}

// cada fumador:
while (1) {
  sem_wait(&combinacion[ID]); // ID = 0, 1 o 2 segÃºn el fumador
  fumar();
  sem_post(&otra_vez); // avisa al agente
}
-----------------------------------


---------------------
Â¿CÃ³mo resolverÃ­as el problema con el P n-ario?
Implementando una primitiva que bloquee hasta que se puedan tomar varios semÃ¡foros a la vez, por ejemplo:

-----------------
Pn(tabaco, papel); // solo cuando ambos disponibles
No existe en pthreads o POSIX, pero teÃ³ricamente se podrÃ­a implementar en el kernel.

Â¿CÃ³mo lo resolverÃ­as usando un array de semÃ¡foros?
Como lo hizo Parnas:

Tres semÃ¡foros (uno por combinaciÃ³n de ingredientes).

El agente hace sem_post solo al semÃ¡foro correspondiente.

Cada fumador hace sem_wait en su semÃ¡foro.

Se evita trywait, mutexes, y polling