# CONTENIDO:
## Este repositorio contiene las prácticas de las siguientes materias , correspondientes a la institución: FCEIA - UNR.
* Programación 2, año 2023
* Recursado Programación 2, año 2024
* Probabilidad y Estadística, año 2025
* Estructuras de Datos y Algoritmos 1 , año 2025.
* Sistemas Operativos I , año 2025.

## Contiene los finales de las siguientes materias:
* Recursado Programación 2, 2024 -> PROMOVIDO: Sólamente C.

#### Temas abordados:

### ***RESUMEN***


Materia | Temas (PYTHON) | Temas (C) |  Temas (R + RStudio) | Temas (Erlang)
:---: | :---: | :---: | :---: | :---:
**Programación 2** | Conceptos Básicos,listas,tuplas,sets,diccionarios,ciclos,condicionales,archivos,módulo Random | Conceptos Básicos,ciclos,condicionales,archivos,estructuras con punteros, memoria dinámica y estática,punteros,char, switch |
**Redictado Prog 2** | Conceptos Básicos,listas,tuplas,diccionarios, tipos de ciclos, tipos de condicionales, archivos, Módulo Random,Streamlit,Math.lib,csv, Proyecto, pytest,strings,receta | Introducción, conceptos básicos, ciclos, tipos de condicionales, switch, punteros,estructuras simples, receta, assert.h y librerías string.h, stdlib.h  (manejo de entrada estándar y personalizada)|
**Probabilidad y Estadística** |  |  | Uso de Software para gráficos y tablas , además de uso de Proporciones,Moda, Mediana, Media Aritmética , etc. |
**Estrucutras de Datos y Algoritmos 1** |  | Punteros a función , Arrays, Listas, Pilas y Colas, Árboles, Heap, Tablas Hash, Introducción a los algoritmos , Ordenamiento |  |
**Sistemas Operativos 1** |  | Signals - Programación y procesos. Regiones de memoria. Creación y destrucción de procesos.Sincronizaciones y comunicación. Condiciones de concurso y regiones críticas. Exclusión mútua. Problemas relacionados. Deadlock y livelock. Programación concurrente.Interbloqueos. Formalismos. Bibliotecas de programación paralela y distribuida. || Sintaxis de Erlang  |

### ***DETALLE***

#### Programación 2,2023:
  ##### *PYTHON:*
    - U1: Introducción a Python
    - U2: El modelo Iterativo
    - U3: Más iteraciones
    - U4: Tuplas y Listas
    - U5: Conjuntos/diccionarios y Archivos
  ##### *C:*
    - U1: Introducción - Sintaxis en C
    - U2: Listas, arrays y bucles
    - U3: Archivos y punteros a función
    - U4: Gestión de la memoria

#### Programación 2,2024:
  ##### *PYTHON:*
    - U1: Familarizándose con Python, la Receta y el Testing
    - U2: Condicionales simples, múltiples, anidados y secuenciados
    - U3: Funciones y recursión
    - U4: Ciclos y módulos
    - U5: Secuencias[Strings, Tuplas y Listas]
    - U6: Diccionarios y Archivos
  ##### *C:*
    - U1: Primeros pasos en C
    - U2: Programando en C
    - U3: Estructuras en C


#### Estructuras de Datos y Algoritmos 1,2025:
  ##### *C:*
    - Unidad 1
        - 1.1 Lenguajes imperativos, algoritmos y estructuras de datos.
        - 1.2 Los lenguajes de programación. El proceso de compilación.
        - 1.3 Estructuras de datos y tipos de datos abstractos.
        - 1.4 Introducción a la complejidad algorítmica
        - 1.5 Herramientas para verificar errores de memoria.
        - 1.6 Herramientas de control de código fuente y versionado con Git.
        - 1.7 Asignación de tareas usando Jira o similar.
    - Unidad 2:
        - 2.1 Arreglos dinámicos
        - 2.2 Estructuras de datos dinámicas y tipos abstractos compuestos
        - 2.3 Listas.
        - 2.4 Listas simplemente enlazadas.
        - 2.5 Listas doblemente enlazadas.
        - 2.6 Listas Circulares
        - 2.7 Listas como arreglos.
        - 2.8 Listas generales
    - Unidad 3:
        - 3.1 El TAD Pila
        - 3.2 El TAD Cola
        - 3.3 Implementación del TAD Pila usando arreglos
        - 3.4 Implementación del TAD Pila usando listas
        - 3.5 Implementación del TAD Cola usando arreglos
        - 3.6 Implementación del TAD Cola usando listas
    - Unidad 4
        - 4.1 Árboles
        - 4.2 Árbol Binario
        - 4.2.1 Árboles de Expresiones Aritméticas
        - 4.2.2 Recorridos
        - 4.3 Búsqueda Binaria
        - 4.4 Árboles de Búsqueda Binaria
        - 4.5 Colas de Prioridades
        - 4.6 Heaps
        - 4.7 Árboles AVL
        - 4.8 Árboles Generales
    - Unidad 5
        - 5.1 Tablas Hash
        - 5.2 Funciones Hash
        - 5.3 Colisiones
        - 5.3.1 Encadenamiento
            - Hashing con listas mezcladas
        - 5.3.2 Direccionamiento Abierto
            - Linear Probing
            - Hashing Doble
    - Unidad 6
        - 6.1 Ordenación.
        - 6.1.1 ¿Por qué ordenar?
        - 6.1.2 El problema de ordenación
        - 6.2 Ordenación por comparación
        - 6.2.1 Burbuja
        - 6.2.2 Selección
        - 6.2.3 Inserción
        - 6.3 Divide and Conquer
        - 6.4 Ordenación por mezcla
        - 6.3.1 Mergesort
        - 6.3.2 Quicksort
        - 6.5 Backtracking
        - 6.6 Algoritmos Greedy
        - 6.7 Programación Dinámica

### Sistemas Operativos I , 2025:

  #### *C:*
    Unidad 1:
        - 1.1. Definición de Sistema operativo.
        - 1.2. Nociones básicas de las funciones de un Sistema Operativo.
        - 1.3. Programación paralela y concurrente. Definiciones. Características. Hitos históricos.
        - 1.4. Ley de Moore.
      Unidad 2:
        - 2.1. Definición de proceso. Etapas y regiones de un proceso.
        - 2.2. Garantías del Sistema Operativo. El rol del scheduler de un Sistema Operativo.
        - 2.3. El Sistema Operativo GNU/Linux.
        - 2.3. Llamadas de Sistema. Primitivas de creación y terminación de procesos.
        - 2.4. Información de un proceso monitoreado por el SO. Descriptores de Archivo.
        - 2.5. Comunicación Interprocesos: Señales. Pipes. Shared Memory. Socket locales.
      Unidad 3:
        - 3.1 Posix Threads.
        - 3.2. Interliving. Recursos compartidos y Región crítica.
        - 3.3. Condiciones de carrera. Problema del jardín Ornamental.
        - 3.4. El problema de Exclusión mutua.
        - 3.5. Algoritmo de Peterson y Lamport como solución al problema de exclusión mutua. Problemas en arquitecturas moderna. Barreras de memoria. Instrucciones por hardware para exclusión mutua.
      Unidad 4:
        - 4.1. Locks y Spinlocks.
        - 4.2. Variables de Condición. Necesidad y uso. Problema de Productores y Consumidores con buffer acotado.
        - 4.3. Monitores. Semántica de Hoare y Mesa.
        - 4.4. Semáforos de Dijkstra. Problema de los escritores y lectores.
        - 4.5. Rendezvous. Problema de la Barbería.
        - 4.6. Barreras de sincronización.
        - 4.7. Deadlocks. Condiciones necesarias para su aparición. Problema de los filósofos comensales. Livelocks.

  #### *Erlang:*
    Unidad 5:
        - 5.1. Mensajes síncronos y asíncronos.
        - 5.2. Modelo CSP. Canales.
        - 5.3. Modelo de Actores. Erlang. Canales en Erlang. Guardas.
        - 5.4. Socket sobre red. Modelo Cliente/Servidor. RPC.
        - 5.5. Modelos de I/O. Kernel queues. Uso de epoll.
    Unidad 6:
        - 6.1. Especificación de ejecución concurrente. Condiciones de Bernstein.
        - 6.2. Propiedades de Safety y livenes.
        - 6.3. API OpenMP. Modelo de ejecución Fork-Join. Directivas de sincronización.
        - 6.4. Modelo de programación para memoría distribuida.
        - 6.5. Bibliotecas de paso de mensajes. MPI. Comunicaciones P2P y colectivas.
        - 6.6. Entornos de ejecución distribuidos.
        - 6.7. Medidas de performance. SpeedUp. Eficiencia
        - 6.8. Erlang Distribuido. Servicio de Distribución de Datos (DDS).
  #### *Otro:*
    Unidad 7:
        - 7.1 Lineamientos para trabajo en equipo
        - 7.2 Herramientas para gestión de tareas y proyectos. Trello.
        - 7.3 Herramientas para trabajo colaborativo. Github. Vscode live share.
        - 7.4 Guías de estilo al programar
        - 7.5 Herramientas de Versionado de código, git. Guías de estilo de versionado.
        - 7.6 Documentación técnica.
        - 7.7 Herramientas para generación automática de documentación. Doxygen. Edoc
